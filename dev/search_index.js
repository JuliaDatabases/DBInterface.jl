var documenterSearchIndex = {"docs":
[{"location":"#DBInterface.jl-Documentation","page":"Home","title":"DBInterface.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"DBInterface.jl provides interface definitions to allow common database operations to be implemented consistently across various database packages.","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DBInterface.connect\nDBInterface.prepare\nDBInterface.@prepare\nDBInterface.execute\nDBInterface.executemany\nDBInterface.executemultiple\nDBInterface.close!\nDBInterface.lastrowid","category":"page"},{"location":"#DBInterface.connect","page":"Home","title":"DBInterface.connect","text":"DBInterface.connect(DB, args...; kw...) => DBInterface.Connection\n\nDatabase packages should overload DBInterface.connect for a specific DB DBInterface.Connection subtype that returns a valid, live database connection that can be queried against.\n\n\n\n\n\n","category":"function"},{"location":"#DBInterface.prepare","page":"Home","title":"DBInterface.prepare","text":"DBInterface.prepare(conn::DBInterface.Connection, sql::AbstractString) => DBInterface.Statement\nDBInterface.prepare(f::Function, sql::AbstractString) => DBInterface.Statement\n\nDatabase packages should overload DBInterface.prepare for a specific DBInterface.Connection subtype, that validates and prepares a SQL statement given as an AbstractString sql argument, and returns a DBInterface.Statement subtype. It is expected that DBInterface.Statements are only valid for the lifetime of the DBInterface.Connection object against which they are prepared. For convenience, users may call DBInterface.prepare(f::Function, sql) which first calls f() to retrieve a valid DBInterface.Connection before calling DBInterface.prepare(conn, sql); this allows deferring connection retrieval and thus statement preparation until runtime, which is often convenient when building applications.\n\n\n\n\n\n","category":"function"},{"location":"#DBInterface.@prepare","page":"Home","title":"DBInterface.@prepare","text":"DBInterface.@prepare f sql\n\nTakes a DBInterface.Connection-retrieval function f and SQL statement sql and will return a prepared statement, via usage of DBInterface.prepare. If the statement has already been prepared, it will be re-used (prepared statements are cached).\n\n\n\n\n\n","category":"macro"},{"location":"#DBInterface.execute","page":"Home","title":"DBInterface.execute","text":"DBInterface.execute(conn::DBInterface.Connection, sql::AbstractString, [params]) => DBInterface.Cursor\nDBInterface.execute(stmt::DBInterface.Statement, [params]) => DBInterface.Cursor\nDBInterface.execute(f::Callable, conn::DBInterface.Connection, sql::AbstractString, [params])\nDBInterface.execute(f::Callable, stmt::DBInterface.Statement, [params])\n\nDatabase packages should overload DBInterface.execute for a valid, prepared DBInterface.Statement subtype (the first method signature is defined in DBInterface.jl using DBInterface.prepare), which takes an optional params argument, which should be an indexable collection (Vector or Tuple) for positional parameters, or a NamedTuple for named parameters. Alternatively, the parameters could be specified as keyword agruments of DBInterface.execute.\n\nDBInterface.execute should return a valid DBInterface.Cursor object, which is any iterator of \"rows\", which themselves must be property-accessible (i.e. implement propertynames and getproperty for value access by name), and indexable (i.e. implement length and getindex for value access by index). These \"result\" objects do not need to subtype DBInterface.Cursor explicitly as long as they satisfy the interface. For DDL/DML SQL statements, which typically do not return results, an iterator is still expected to be returned that just iterates nothing, i.e. an \"empty\" iterator.\n\nNote that DBInterface.execute returns ***a single*** DBInterface.Cursor, which represents a single resultset from the database. For use-cases involving multiple result-sets from a single query, see DBInterface.executemultiple.\n\nIf function f is provided, DBInterface.execute will return the result of applying f to the DBInterface.Cursor object and close the prepared statement upon exit.\n\n\n\n\n\n","category":"function"},{"location":"#DBInterface.executemany","page":"Home","title":"DBInterface.executemany","text":"DBInterface.executemany(conn::DBInterface.Connection, sql::AbstractString, [params]) => Nothing\nDBInterface.executemany(stmt::DBInterface.Statement, [params]) => Nothing\n\nSimilar in usage to DBInterface.execute, but allows passing multiple sets of parameters to be executed in sequence. params, like for DBInterface.execute, should be an indexable collection (Vector or Tuple) or NamedTuple, but instead of a single scalar value per parameter, an indexable collection should be passed for each parameter. By default, each set of parameters will be looped over and DBInterface.execute will be called for each. Note that no result sets or cursors are returned for any execution, so the usage is mainly intended for bulk INSERT statements.\n\n\n\n\n\n","category":"function"},{"location":"#DBInterface.executemultiple","page":"Home","title":"DBInterface.executemultiple","text":"DBInterface.executemultiple(conn::DBInterface.Connection, sql::AbstractString, [params]) => Cursor-iterator\nDBInterface.executemultiple(stmt::DBInterface.Statement, [params]) => Cursor-iterator\n\nSome databases allow returning multiple resultsets from a \"single\" query (typically semi-colon (;) separated statements, or from calling stored procedures). This function takes the exact same arguments as DBInterface.execute, but instead of returning a single Cursor, it returns an iterator of Cursors. This function defines a generic fallback that just returns (DBInterface.execute(stmt, params),), a length-1 tuple for a single Cursor resultset.\n\n\n\n\n\n","category":"function"},{"location":"#DBInterface.close!","page":"Home","title":"DBInterface.close!","text":"DBInterface.close!(conn::DBInterface.Connection)\n\nImmediately closes a database connection so further queries cannot be processed.\n\n\n\n\n\nDBInterface.close!(stmt::DBInterface.Statement)\n\nClose a prepared statement so further queries cannot be executed.\n\n\n\n\n\nDBInterface.close!(x::Cursor) => Nothing\n\nImmediately close a resultset cursor. Database packages should overload for the provided resultset Cursor object.\n\n\n\n\n\n","category":"function"},{"location":"#DBInterface.lastrowid","page":"Home","title":"DBInterface.lastrowid","text":"DBInterface.lastrowid(x::Cursor) => Int\n\nIf supported by the specific database cursor, returns the last inserted row id after executing an INSERT statement.\n\n\n\n\n\n","category":"function"},{"location":"#Types","page":"Home","title":"Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DBInterface.Connection\nDBInterface.Statement\nDBInterface.Cursor","category":"page"},{"location":"#DBInterface.Connection","page":"Home","title":"DBInterface.Connection","text":"Database packages should subtype DBInterface.Connection which represents a connection to a database\n\n\n\n\n\n","category":"type"},{"location":"#DBInterface.Statement","page":"Home","title":"DBInterface.Statement","text":"Database packages should provide a DBInterface.Statement subtype which represents a valid, prepared SQL statement that can be executed repeatedly\n\n\n\n\n\n","category":"type"},{"location":"#DBInterface.Cursor","page":"Home","title":"DBInterface.Cursor","text":"Any object that iterates \"rows\", which are objects that are property-accessible and indexable. See DBInterface.execute for more details on fetching query results.\n\n\n\n\n\n","category":"type"}]
}
